(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{194:function(e,t,a){"use strict";a.r(t);var s=a(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"archive-push"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#archive-push","aria-hidden":"true"}},[e._v("#")]),e._v(" archive-push")]),a("p",[e._v("The WAL segment may be pushed immediately to the archive or stored locally depending on the value of "),a("code",[e._v("archive-async")]),e._v(".")]),a("h2",{attrs:{id:"archive-async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#archive-async","aria-hidden":"true"}},[e._v("#")]),e._v(" --archive-async")]),a("p",[e._v("Push/get WAL segments asynchronously.")]),a("p",[e._v("Enables asynchronous operation for the "),a("code",[e._v("archive-push")]),e._v(" and "),a("code",[e._v("archive-get")]),e._v(" commands.")]),a("p",[e._v("Asynchronous operation is more efficient because it can reuse connections and take advantage of parallelism. See the "),a("code",[e._v("spool-path")]),e._v(", "),a("code",[e._v("archive-get-queue-max")]),e._v(", and "),a("code",[e._v("archive-push-queue-max")]),e._v(" options for more information.")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("default: n\nexample: --archive-async\n")])])]),a("h2",{attrs:{id:"archive-push-queue-max"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#archive-push-queue-max","aria-hidden":"true"}},[e._v("#")]),e._v(" --archive-push-queue-max")]),a("p",[e._v("Maximum size of the PostgreSQL archive queue.")]),a("p",[e._v("After the limit is reached, the following will happen:")]),a("ul",[a("li",[e._v("pgBackRest will notify PostgreSQL that the WAL was successfully archived, then "),a("code",[e._v("DROP IT")]),e._v(".")]),a("li",[e._v("A warning will be output to the Postgres log.")])]),a("p",[e._v("If this occurs then the archive log stream will be interrupted and PITR will not be possible past that point. A new backup will be required to regain full restore capability.")]),a("p",[e._v("In asynchronous mode the entire queue will be dropped to prevent spurts of WAL getting through before the queue limit is exceeded again.")]),a("p",[e._v("The purpose of this feature is to prevent the log volume from filling up at which point Postgres will stop completely. Better to lose the backup than have PostgreSQL go down.")]),a("p",[e._v("Size can be entered in bytes (default) or KB, MB, GB, TB, or PB where the multiplier is a power of 1024.")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("allowed: 0-4503599627370496\nexample: --archive-push-queue-max=1GB\nDeprecated Name: archive-queue-max\n")])])]),a("h2",{attrs:{id:"archive-timeout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#archive-timeout","aria-hidden":"true"}},[e._v("#")]),e._v(" --archive-timeout")]),a("p",[e._v("Archive timeout.")]),a("p",[e._v("Set maximum time, in seconds, to wait for each WAL segment to reach the pgBackRest archive repository. The timeout applies to the check and backup commands when waiting for WAL segments required for backup consistency to be archived.")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("default: 60\nallowed: 0.1-86400\nexample: --archive-timeout=30\n")])])])])}],!1,null,null,null);t.default=r.exports}}]);